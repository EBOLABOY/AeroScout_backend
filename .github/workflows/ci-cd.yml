name: CI-CD

on:
  push:
    branches: ["master"]
  workflow_dispatch:

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Lint & Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry config virtualenvs.create false
          poetry install --no-interaction --no-root

      - name: Ruff check
        run: poetry run ruff check .

      - name: Run tests
        run: |
          set -e
          if ! poetry run pytest -q; then
            status=$?
            if [ "$status" -eq 5 ]; then
              echo "Pytest exited with code 5 (no tests found). Treating as success."
            else
              exit "$status"
            fi
          fi

  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: quality
    if: github.ref == 'refs/heads/master'
    steps:
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}.git
          BRANCH: master
          DEPLOY_DIR: /opt/aeroscout
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: REPO_URL,BRANCH,DEPLOY_DIR,SUPABASE_ACCESS_TOKEN,SUPABASE_DB_PASSWORD,SUPABASE_JWT_SECRET
          script: |
            set -euo pipefail

            DOCKER="docker"
            if ! docker info >/dev/null 2>&1; then
              if sudo -n docker info >/dev/null 2>&1; then
                DOCKER="sudo docker"
              else
                echo 'Docker daemon is not reachable. Please ensure docker is installed and accessible.' >&2
                exit 1
              fi
            fi

            if ${DOCKER} compose version >/dev/null 2>&1; then
              COMPOSE_CMD="${DOCKER} compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_CMD="docker-compose"
            elif command -v sudo >/dev/null 2>&1 && sudo -n docker-compose version >/dev/null 2>&1; then
              COMPOSE_CMD="sudo docker-compose"
            else
              echo 'Docker Compose is not available on the server.' >&2
              exit 1
            fi

            echo "[Deploy] Using compose command: ${COMPOSE_CMD}"

            echo "[Deploy] Ensuring deploy directory ${DEPLOY_DIR}"
            if [ ! -d "${DEPLOY_DIR}" ]; then
              sudo mkdir -p "${DEPLOY_DIR}"
              sudo chown -R "$USER":"$USER" "${DEPLOY_DIR}"
            fi

            if [ ! -d "${DEPLOY_DIR}/.git" ]; then
              git clone --branch "${BRANCH}" "${REPO_URL}" "${DEPLOY_DIR}"
            fi

            cd "${DEPLOY_DIR}"
            git fetch origin "${BRANCH}"
            git checkout "${BRANCH}"
            git reset --hard "origin/${BRANCH}"

            touch .env

            update_env_var() {
              local key="$1"
              local value="$2"
              if [ -z "${value}" ]; then
                return
              fi
              local escaped
              escaped=$(printf '%s\n' "${value}" | sed -e 's/[\\/&]/\\&/g')
              if grep -q "^${key}=" .env; then
                sed -i "s|^${key}=.*|${key}=${escaped}|" .env
              else
                printf '%s=%s\n' "${key}" "${value}" >> .env
              fi
            }

            update_env_var "SUPABASE_ACCESS_TOKEN" "${SUPABASE_ACCESS_TOKEN:-}"
            update_env_var "SUPABASE_DB_PASSWORD" "${SUPABASE_DB_PASSWORD:-}"
            update_env_var "SUPABASE_JWT_SECRET" "${SUPABASE_JWT_SECRET:-}"

            ${COMPOSE_CMD} pull
            ${COMPOSE_CMD} up -d --build

            echo "[Deploy] Waiting for application health..."
            for attempt in $(seq 1 15); do
              if ${COMPOSE_CMD} exec -T app curl -sf http://localhost:8000/health >/dev/null 2>&1; then
                echo '✅ Application is healthy.'
                exit 0
              fi
              echo "Waiting for health check (${attempt}/15)..."
              sleep 4
            done

            echo '❌ Health check failed after waiting period. Showing recent logs:' >&2
            ${COMPOSE_CMD} logs --tail=200 app || true
            exit 1

